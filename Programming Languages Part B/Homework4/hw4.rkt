
#lang racket

(provide (all-defined-out)) ;; so we can put tests in a second file

;; put your code below

;; (Int, Int, Int -> listOf Int)
;; returns a list of numbers from low to high (possibly inclusive) based on the stride
;; ASSUME: all params are numbers, and stride is positive
(define (sequence low high stride)
  (cond [(> low high) null]
        [(<= low high) (cons low (sequence (+ low stride) high stride))]
        [#t null]))


;; (listOf String, String -> listOf String)
;; appends the given string to each of the elements in the list and returns the resulting list
(define (string-append-map xs suffix)
  (map (lambda (e) (string-append e suffix)) xs))


;; (listOf 'a, Int -> 'a)
;; returns the ith element of the list where i is the remainder of dividing n by the list's length
;; returns errors if the number is negative or if the list is empty
(define (list-nth-mod xs n)
  (cond [(< n 0) (error "list-nth-mod: negative number")]
        [(null? xs) (error "list-nth-mod: empty list")]
        [#t (car
             (list-tail xs
                        (remainder n (length xs))))]))
                  

;; (streamOf 'a, Int -> listOf 'a)
;; takes in a stream and an integer and returns the first n elements generated by the stream
;; ASSUME n is positive
(define (stream-for-n-steps stream n)
  (if (<= n 0)
      null
      (let ([pair (stream)])
        (cons (car pair)
              (stream-for-n-steps (cdr pair) (- n 1))))))


;; () -> streamOf Int
;; generates a stream of ints where the numbers divisible by 5 are negative
(define funny-number-stream
  (letrec ([f (lambda (ans)
                (if (= (modulo ans 5) 0)
                    (cons (- ans) (lambda () (f (+ 1 ans))))
                    (cons ans (lambda () (f (+ 1 ans))))))])
    (lambda () (f 1))))


;; () -> streamOf String
;; produces a stream that generates the alternating strings "dan.jpg" "dog.jpg"
(define dan-then-dog
  (letrec ([f (lambda (ans)
                (if (= (modulo ans 2) 0)
                    (cons "dan.jpg" (lambda () (f (+ 1 ans))))
                    (cons "dog.jpg" (lambda () (f (+ 1 ans))))))])
    (lambda () (f 0))))


;; streamOf 'a -> streamOf (0, 'a)
;; takes in a stream and returns another stream that produces pairs (0, v) if the i'th element would produce v
(define (stream-add-zero s)
  (letrec ([f (lambda (s)
                (let ([pr (s)])
                  (cons (cons 0 (car pr)) (lambda () (f (cdr pr))))))])
    (lambda () (f s))))



;; listOf 'a, listOf 'b -> streamOf ('a 'b)
;; returns a stream of pairs where the first element is from xs and the second from ys
;; ASSUME both lists are non-empty
(define (cycle-lists xs ys)
  (letrec ([f (lambda (n)
                (cons (cons (list-nth-mod xs n)
                            (list-nth-mod ys n))
                      (lambda () (f (+ n 1)))))])
    (lambda () (f 0))))


;; 'a, vectorOf 'b -> False or ('c, 'd)
;; takes in a vector and a value and returns either false or a pair - behaves like assoc
(define (vector-assoc v vec)
  (letrec ([find-vals (lambda (n)
                        (if (= n (vector-length vec))
                            #f
                            (let ([el (vector-ref vec n)])
                              (if (pair? el)
                                  (if (equal? (car el) v)
                                      el
                                      (find-vals (+ 1 n)))
                                  (find-vals (+ 1 n))))))])
    (find-vals 0)))


;; listOf 'a, Int -> (func 'a) -> Int -> ('c 'd) or #f
;; takes in a list xs and a value n and returns a function that takes one arg v, that behaves like (assoc v xs)
;; ASSUME n is positive
;; builds an n-sized cache in order to make computation faster
(define (cached-assoc xs n)
  (letrec ([memo (make-vector n #f)]
           [pos 0]
           [my-assoc (lambda (v)
                       (let ([res (vector-assoc v memo)])
                         (println res)
                         (if res
                             res
                             (seek v xs))))]
                             
           [seek (lambda (v xs)
                   (cond [(null? xs) #f]
                         [#t (if (pair? (car xs))
                                 (if (equal? v (car (car xs)))
                                     (begin
                                       (vector-set! memo pos (car xs))
                                       (if (>= pos n)
                                           (set! pos 0)
                                           (set! pos (+ 1 pos)))
                                       (car xs))
                                     (seek v (cdr xs)))
                                 (seek v (cdr xs)))]))])
    my-assoc))


;; CHALLENGE PROBLEM
;; assume e1 and e2 produce numbers
;; functionality: keeps evaluating e2 while e2 is strictly less than e1
;; if evaluation terminates, return #t
(define-syntax while-less
  (syntax-rules (while-less do)
    [(while-less e1 do e2)
     ((let ([top e1])
        (letrec ([while (lambda ()
                          (if (<= top e2)
                              #t
                              (while)))])
          while)))]))
          
     
